

interface OnboardingData {
  tone: string
  voice: string
  rawness: string
  depth: string
  learning: string
  engagement: string
  safety: {
    crisisSupport: boolean
    contentWarnings: boolean
    skipTriggers: boolean
  }
  goals: string[]
  experience: string
  timeCommitment: string
}

interface DiagnosticQuestion {
  id: number
  category: 'trauma' | 'patterns' | 'relationships' | 'self-image' | 'coping' | 'goals' | 'custom'
  question: string
  followUp?: string
  options?: string[]
  adaptive?: {
    tone: string[]
    rawness: string[]
    depth: string[]
  }
  aiPrompt?: string
}

interface OnboardingAnalysis {
  recommendedQuestionCount: number
  focusAreas: string[]
  communicationStyle: string
  intensityLevel: string
  depthLevel: string
  safetyConsiderations: string[]
  customCategories: string[]
}

export class AIOnboardingAnalyzer {
  private openaiKey: string
  private claudeKey: string
  private allowFallback: boolean

  constructor(options?: { allowFallback?: boolean }) {
    // SECURITY: Never log API keys - only load from environment variables
    this.openaiKey = process.env.OPENAI_API_KEY || ''
    this.claudeKey = process.env.CLAUDE_API_KEY || ''
    const envAllowFallback = process.env.ALLOW_AI_FALLBACK === 'true'
    this.allowFallback = (typeof options?.allowFallback === 'boolean')
      ? Boolean(options?.allowFallback)
      : envAllowFallback
  }

  async analyzeOnboardingAndGenerateQuestions(
    onboardingData: OnboardingData
  ): Promise<{
    analysis: OnboardingAnalysis
    questions: DiagnosticQuestion[]
  }> {
    console.log('Starting AI onboarding analysis...')
    
    // First, analyze the onboarding data
    const analysis = await this.analyzeOnboardingData(onboardingData)
    console.log('Analysis completed:', analysis)
    
    // Generate personalized questions based on analysis
    const questions = await this.generatePersonalizedQuestions(onboardingData, analysis)
    console.log('Questions generated:', questions.length)
    
    if (!questions || questions.length === 0) {
      throw new Error('No questions were generated by AI')
    }
    
    return { analysis, questions }
  }

  private async analyzeOnboardingData(onboardingData: OnboardingData): Promise<OnboardingAnalysis> {
    const prompt = `
You are a trauma-informed therapist analyzing a client's onboarding preferences to create a personalized diagnostic experience.

ONBOARDING DATA:
- Communication Style: ${onboardingData.tone} tone, ${onboardingData.voice} voice
- Content Intensity: ${onboardingData.rawness} rawness
- Exploration Depth: ${onboardingData.depth} depth
- Learning Style: ${onboardingData.learning}
- Engagement Level: ${onboardingData.engagement}
- Goals: ${onboardingData.goals.join(', ')}
- Experience Level: ${onboardingData.experience}
- Time Commitment: ${onboardingData.timeCommitment}
- Safety: Crisis Support: ${onboardingData.safety.crisisSupport}, Content Warnings: ${onboardingData.safety.contentWarnings}, Skip Triggers: ${onboardingData.safety.skipTriggers}

ANALYZE AND PROVIDE:
1. Recommended number of diagnostic questions (MUST be between 4-10 based on engagement, time, and depth)
2. Primary focus areas for this client
3. Optimal communication style
4. Appropriate intensity level
5. Suitable depth level
6. Safety considerations
7. Custom question categories based on their goals

IMPORTANT: The question count must be between 4-10 questions. Consider:
- Passive engagement = 4-5 questions
- Moderate engagement = 6-8 questions  
- Active engagement = 8-10 questions
- 5min time commitment = 4 questions
- 15min time commitment = 5-6 questions
- 30min time commitment = 7-8 questions
- 60min time commitment = 9-10 questions
- Surface depth = 4-5 questions
- Moderate depth = 6-7 questions
- Deep/Profound depth = 8-10 questions

Respond in JSON format:
{
  "recommendedQuestionCount": 5,
  "focusAreas": ["area1", "area2"],
  "communicationStyle": "description",
  "intensityLevel": "mild/moderate/intense",
  "depthLevel": "surface/moderate/deep/profound",
  "safetyConsiderations": ["consideration1", "consideration2"],
  "customCategories": ["category1", "category2"]
}
`

    // Try OpenAI first
    if (this.openaiKey) {
      try {
        console.log('Attempting OpenAI analysis...')
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.openaiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: 'gpt-4',
            messages: [
              {
                role: 'system',
                content: 'You are a trauma-informed therapist specializing in personalized diagnostic experiences. Provide analysis in the exact JSON format requested.'
              },
              {
                role: 'user',
                content: prompt
              }
            ],
            temperature: 0.7,
            max_tokens: 1500
          })
        })

        if (response.ok) {
          const data = await response.json()
          const analysisText = data.choices[0].message.content
          
          try {
            const analysis = JSON.parse(analysisText)
            
            // Validate and enforce question count limits
            if (analysis.recommendedQuestionCount) {
              analysis.recommendedQuestionCount = Math.max(4, Math.min(10, analysis.recommendedQuestionCount))
              console.log(`Adjusted question count to: ${analysis.recommendedQuestionCount}`)
            }
            
            console.log('OpenAI analysis successful')
            return analysis
          } catch {
            console.log('OpenAI response parsing failed, trying Claude...')
            throw new Error('Failed to parse OpenAI response')
          }
        } else {
          console.log('OpenAI request failed, trying Claude...')
          throw new Error('OpenAI request failed')
        }
      } catch (openaiError) {
        console.log('OpenAI error:', openaiError)
        // Fall through to Claude
      }
    }

    // Try Claude as fallback
    if (this.claudeKey) {
      try {
        console.log('Attempting Claude analysis...')
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
                                  'x-api-key': this.claudeKey,
            'Content-Type': 'application/json',
            'anthropic-version': '2023-06-01'
          },
          body: JSON.stringify({
                                  model: 'claude-3-5-sonnet-20241022',
            max_tokens: 1500,
            messages: [
              {
                role: 'user',
                content: prompt
              }
            ]
          })
        })

        if (response.ok) {
          const data = await response.json()
          const analysisText = data.content[0].text
          
          try {
            const analysis = JSON.parse(analysisText)
            
            // Validate and enforce question count limits
            if (analysis.recommendedQuestionCount) {
              analysis.recommendedQuestionCount = Math.max(4, Math.min(10, analysis.recommendedQuestionCount))
              console.log(`Adjusted question count to: ${analysis.recommendedQuestionCount}`)
            }
            
            console.log('Claude analysis successful')
            return analysis
          } catch {
            console.log('Claude response parsing failed, using fallback...')
            throw new Error('Failed to parse Claude response')
          }
        } else {
          console.log('Claude request failed, using fallback...')
          throw new Error('Claude request failed')
        }
      } catch (claudeError) {
        console.log('Claude error:', claudeError)
        // Fall through to fallback
      }
    }

    // If both AI services fail or no keys
    if (!this.allowFallback) {
      throw new Error('AI analysis unavailable and fallback disabled')
    }
    console.log('Both OpenAI and Claude failed, using fallback analysis (allowed)')
    return this.getFallbackAnalysis(onboardingData)
  }

  private async generatePersonalizedQuestions(
    onboardingData: OnboardingData,
    analysis: OnboardingAnalysis
  ): Promise<DiagnosticQuestion[]> {
    const questions: DiagnosticQuestion[] = []
    
    // Generate questions based on recommended count
    for (let i = 1; i <= analysis.recommendedQuestionCount; i++) {
      const question = await this.generateQuestion(i, onboardingData, analysis)
      questions.push(question)
    }
    
    return questions
  }

  private async generateQuestion(
    questionNumber: number,
    onboardingData: OnboardingData,
    analysis: OnboardingAnalysis
  ): Promise<DiagnosticQuestion> {
    const prompt = `
Generate diagnostic question ${questionNumber} of ${analysis.recommendedQuestionCount} for a trauma healing assessment.

CLIENT PROFILE:
- Communication: ${onboardingData.tone} tone, ${onboardingData.voice} voice
- Intensity: ${onboardingData.rawness}
- Depth: ${onboardingData.depth}
- Goals: ${onboardingData.goals.join(', ')}
- Experience: ${onboardingData.experience}

ANALYSIS:
- Focus Areas: ${analysis.focusAreas.join(', ')}
- Communication Style: ${analysis.communicationStyle}
- Intensity Level: ${analysis.intensityLevel}
- Depth Level: ${analysis.depthLevel}
- Custom Categories: ${analysis.customCategories.join(', ')}

QUESTION ${questionNumber} SPECIFICATIONS:
- Should match their communication style
- Appropriate for their intensity level
- Suitable for their depth preference
- Focus on their specific goals
- Trauma-informed and safe

Respond in JSON format:
{
  "id": ${questionNumber},
  "category": "trauma/patterns/relationships/self-image/coping/goals/custom",
  "question": "The main question",
  "followUp": "Optional follow-up question",
  "options": ["option1", "option2"] (only if multiple choice is appropriate),
  "adaptive": {
    "tone": ["tone1", "tone2"],
    "rawness": ["rawness1", "rawness2"],
    "depth": ["depth1", "depth2"]
  },
  "aiPrompt": "Specific instructions for AI analysis of responses"
}
`

    // Try OpenAI first (if configured). On failure, try Claude (if configured).
    let lastError: unknown = null
    if (this.openaiKey) {
      try {
        console.log(`Attempting OpenAI question ${questionNumber}...`)
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.openaiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: 'gpt-4',
            messages: [
              {
                role: 'system',
                content: 'You are a trauma-informed therapist creating personalized diagnostic questions. Generate engaging, safe, and effective questions in the exact JSON format requested.'
              },
              {
                role: 'user',
                content: prompt
              }
            ],
            temperature: 0.8,
            max_tokens: 1000
          })
        })

        if (response.ok) {
          const data = await response.json()
          const questionText = data.choices[0].message.content
          try {
            const question = JSON.parse(questionText)
            console.log(`OpenAI question ${questionNumber} successful`)
            return question
          } catch (parseErr) {
            console.log(`OpenAI question ${questionNumber} parsing failed; will try Claude if available...`)
            lastError = parseErr
          }
        } else {
          console.log(`OpenAI question ${questionNumber} failed with status ${response.status}; will try Claude if available...`)
          lastError = new Error('OpenAI request failed')
        }
      } catch (openaiError) {
        console.log(`OpenAI question ${questionNumber} error:`, openaiError)
        lastError = openaiError
      }
    }

    if (this.claudeKey) {
      try {
        console.log(`Attempting Claude question ${questionNumber}...`)
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'x-api-key': this.claudeKey,
            'Content-Type': 'application/json',
            'anthropic-version': '2023-06-01'
          },
          body: JSON.stringify({
            model: 'claude-3-5-sonnet-20241022',
            max_tokens: 1000,
            messages: [
              {
                role: 'user',
                content: prompt
              }
            ]
          })
        })

        if (response.ok) {
          const data = await response.json()
          const questionText = data.content[0].text
          try {
            const question = JSON.parse(questionText)
            console.log(`Claude question ${questionNumber} successful`)
            return question
          } catch (parseErr) {
            console.log(`Claude question ${questionNumber} parsing failed`)
            lastError = parseErr
          }
        } else {
          console.log(`Claude question ${questionNumber} failed with status ${response.status}`)
          lastError = new Error('Claude request failed')
        }
      } catch (claudeError) {
        console.log(`Claude question ${questionNumber} error:`, claudeError)
        lastError = claudeError
      }
    }

    // If both AI services fail
    if (!this.allowFallback) {
      // Preserve context from the last provider error if available
      const message = lastError instanceof Error ? `${lastError.message}` : 'AI question generation unavailable and fallback disabled'
      throw new Error(message)
    }
    console.log(`Both AI services failed for question ${questionNumber}, using fallback (allowed)...`)
    return this.getFallbackQuestion(questionNumber, onboardingData, analysis)
  }

  private getFallbackAnalysis(onboardingData: OnboardingData): OnboardingAnalysis {
    // Determine question count based on engagement, time commitment, and depth (4-10 range)
    let questionCount = 6 // default moderate baseline

    // Adjust based on engagement level
    if (onboardingData.engagement === 'passive') {
      questionCount = 5
    } else if (onboardingData.engagement === 'active') {
      questionCount = 8
    }

    // Adjust based on time commitment caps
    if (onboardingData.timeCommitment === '5min') {
      questionCount = Math.min(questionCount, 4)
    } else if (onboardingData.timeCommitment === '15min') {
      questionCount = Math.min(questionCount, 6)
    } else if (onboardingData.timeCommitment === '30min') {
      questionCount = Math.min(questionCount, 8)
    } else if (onboardingData.timeCommitment === '60min') {
      questionCount = Math.min(questionCount, 10)
    }

    // Adjust based on depth preference caps
    if (onboardingData.depth === 'surface') {
      questionCount = Math.min(questionCount, 5)
    } else if (onboardingData.depth === 'moderate') {
      questionCount = Math.max(6, Math.min(questionCount, 7))
    } else if (onboardingData.depth === 'deep' || onboardingData.depth === 'profound') {
      questionCount = Math.min(Math.max(questionCount, 8), 10)
    }

    // Ensure question count is within 4-10 range
    questionCount = Math.max(4, Math.min(10, questionCount))

    // Determine focus areas based on goals
    const focusAreas = onboardingData.goals.length > 0 ? onboardingData.goals : ['general healing']

    return {
      recommendedQuestionCount: questionCount,
      focusAreas,
      communicationStyle: `${onboardingData.tone} and ${onboardingData.voice}`,
      intensityLevel: onboardingData.rawness,
      depthLevel: onboardingData.depth,
      safetyConsiderations: [
        'self-compassion',
        'gradual progress',
        'professional support if needed'
      ],
      customCategories: onboardingData.goals
    }
  }

  private getFallbackQuestions(onboardingData: OnboardingData): DiagnosticQuestion[] {
    const analysis = this.getFallbackAnalysis(onboardingData)
    const questions: DiagnosticQuestion[] = []

    // Ensure we don't exceed 10 questions
    const questionCount = Math.min(analysis.recommendedQuestionCount, 10)
    console.log(`Generating ${questionCount} fallback questions`)

    for (let i = 1; i <= questionCount; i++) {
      questions.push(this.getFallbackQuestion(i, onboardingData, analysis))
    }

    return questions
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  private getFallbackQuestion(
    questionNumber: number,
    onboardingData: OnboardingData,
    _analysis: OnboardingAnalysis
  ): DiagnosticQuestion {
    const questionTemplates = {
      trauma: [
        {
          question: "What's the most challenging experience you've had to overcome?",
          followUp: "How did that experience change the way you see yourself?"
        },
        {
          question: "How do you typically respond when you feel overwhelmed?",
          followUp: "What would help you feel more supported in those moments?"
        },
        {
          question: "What triggers your strongest emotional reactions?",
          followUp: "How do you wish you could respond differently?"
        }
      ],
      patterns: [
        {
          question: "What's a behavior you keep repeating even though you know it's not good for you?",
          followUp: "What do you think is the deeper reason behind this pattern?"
        },
        {
          question: "What patterns do you notice in your relationships?",
          followUp: "How do these patterns serve you, even if they're not ideal?"
        },
        {
          question: "How do you typically handle stress or difficult situations?",
          followUp: "What would be a healthier way to cope with these challenges?"
        }
      ],
      relationships: [
        {
          question: "What's your biggest challenge in relationships?",
          followUp: "How does this challenge show up in your daily interactions?"
        },
        {
          question: "How do you typically communicate when you're upset?",
          followUp: "What would better communication look like for you?"
        },
        {
          question: "What do you need most from the people in your life?",
          followUp: "How do you express these needs to others?"
        }
      ],
      'self-image': [
        {
          question: "What would you change about yourself if you could?",
          followUp: "What's stopping you from making these changes?"
        },
        {
          question: "How do you see yourself compared to others?",
          followUp: "Where do you think this comparison comes from?"
        },
        {
          question: "What are your biggest strengths and weaknesses?",
          followUp: "How do your weaknesses actually serve you in some ways?"
        }
      ],
      coping: [
        {
          question: "How do you usually deal with difficult emotions?",
          followUp: "What would be a more helpful way to process these feelings?"
        },
        {
          question: "What helps you feel better when you're struggling?",
          followUp: "How could you make these coping strategies more accessible?"
        },
        {
          question: "What coping strategies have you tried in the past?",
          followUp: "Which ones worked best and why?"
        }
      ],
      goals: [
        {
          question: "What's the biggest thing holding you back from the life you want?",
          followUp: "What small step could you take today toward that life?"
        },
        {
          question: "What would success look like for you?",
          followUp: "How would you know you're making progress?"
        },
        {
          question: "What's one change you'd like to make in your life?",
          followUp: "What support would you need to make this change?"
        }
      ]
    }

    const categories = Object.keys(questionTemplates)
    const category = categories[questionNumber % categories.length] as keyof typeof questionTemplates
    const categoryQuestions = questionTemplates[category]
    const questionIndex = Math.floor(questionNumber / categories.length) % categoryQuestions.length
    const { question, followUp } = categoryQuestions[questionIndex]

    return {
      id: questionNumber,
      category: category as 'trauma' | 'patterns' | 'relationships' | 'self-image' | 'coping' | 'goals',
      question,
      followUp,
      adaptive: {
        tone: [onboardingData.tone],
        rawness: [onboardingData.rawness],
        depth: [onboardingData.depth]
      },
      aiPrompt: `Analyze this response for ${category} patterns and provide trauma-informed insights.`
    }
  }
}
