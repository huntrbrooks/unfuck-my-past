import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import { db, users, diagnosticResponses, progress, purchases, diagnosticSummaries } from '../../../db'
import { eq, and } from 'drizzle-orm'

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth()
    
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { type, dayNumber, dayContent, moods } = await request.json()

    // Get user data
    const userResult = await db.select().from(users).where(eq(users.id, userId)).limit(1)
    if (!userResult || userResult.length === 0) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    const user = userResult[0]
    const safetyData = typeof user.safety === 'string' ? JSON.parse(user.safety) : user.safety

    // Handle different export types
    switch (type) {
      case 'diagnostic-summary-txt':
        return await handleDiagnosticSummaryTXT(userId, safetyData)
      
      case 'diagnostic-comprehensive-txt':
        return await handleDiagnosticComprehensiveTXT(userId)
      
      case 'program-structure-txt':
        return await handleProgramStructureTXT(userId, safetyData)
      
      case 'program-daily-txt':
        return await handleProgramDailyTXT(userId, safetyData, dayNumber, dayContent)
      
      case 'diagnostic-questions-txt':
        return await handleDiagnosticQuestionsTXT(userId)
      
      case 'all-txt':
        return await handleAllTXT(userId, safetyData, moods)
      
      default:
        return NextResponse.json({ error: 'Invalid export type' }, { status: 400 })
    }

  } catch (error) {
    console.error('Error exporting data:', error)
    return NextResponse.json(
      { error: 'Failed to export data' },
      { status: 500 }
    )
  }
}

async function handleDiagnosticSummaryTXT(userId: string, safetyData: { diagnosticSummary?: { content: string }; keyInsights?: string }) {
  const summary = safetyData.diagnosticSummary?.content || 'No diagnostic summary available'
  const keyInsights = safetyData.keyInsights || 'No key insights available'
  
  const text = `üîç DIAGNOSTIC SUMMARY REPORT
Your personalized trauma analysis & healing insights
Generated on ${new Date().toLocaleDateString()}

================================================================================

üìã EXECUTIVE SUMMARY
================================================================================

${summary}

================================================================================

üí° KEY INSIGHTS
================================================================================

${keyInsights}

================================================================================

End of Report
Generated by Unfuck Your Past - AI-Driven Healing Platform`

  return NextResponse.json({
    success: true,
    data: text,
    filename: `diagnostic-summary-${userId}-${Date.now()}.txt`,
    mimeType: 'text/plain'
  })
}

async function handleDiagnosticComprehensiveTXT(userId: string) {
  try {
    // Get comprehensive report from database
    const reportResult = await db
      .select()
      .from(diagnosticSummaries)
      .where(and(
        eq(diagnosticSummaries.userId, userId),
        eq(diagnosticSummaries.type, 'comprehensive_report')
      ))
      .limit(1)

    if (!reportResult || reportResult.length === 0) {
      return NextResponse.json({
        success: true,
        data: 'No comprehensive diagnostic report found. Please purchase and generate the full report first.',
        filename: `diagnostic-comprehensive-${userId}-${Date.now()}.txt`,
        mimeType: 'text/plain'
      })
    }

    const report = reportResult[0].summary

    const text = `üîç COMPREHENSIVE DIAGNOSTIC REPORT
Your complete trauma analysis, healing roadmap & actionable recommendations
Generated on ${new Date().toLocaleDateString()}

================================================================================

${report}

================================================================================

End of Comprehensive Report
Generated by Unfuck Your Past - AI-Driven Healing Platform`

    return NextResponse.json({
      success: true,
      data: text,
      filename: `diagnostic-comprehensive-${userId}-${Date.now()}.txt`,
      mimeType: 'text/plain'
    })

  } catch (error) {
    console.error('Error generating comprehensive report TXT:', error)
    return NextResponse.json({
      success: false,
      error: 'Failed to generate comprehensive report'
    }, { status: 500 })
  }
}

async function handleProgramStructureTXT(userId: string, safetyData: { programStructure?: string }) {
  const programData = safetyData.programStructure || 'No program structure available'
  
  const text = `üå± 30-DAY HEALING PROGRAM STRUCTURE
Your personalized healing journey overview
Generated on ${new Date().toLocaleDateString()}

================================================================================

${programData}

================================================================================

End of Program Structure
Generated by Unfuck Your Past - AI-Driven Healing Platform`

  return NextResponse.json({
    success: true,
    data: text,
    filename: `program-structure-${userId}-${Date.now()}.txt`,
    mimeType: 'text/plain'
  })
}

async function handleProgramDailyTXT(userId: string, _safetyData: Record<string, unknown>, dayNumber: number, dayContent: { content: { mainFocus: string; guidedPractice: string; challenge: string; journalingPrompt: string; reflection: string; weather?: string; sleep?: string; holistic?: string } }) {
  if (!dayNumber || typeof dayNumber !== 'number') {
    return NextResponse.json({
      success: false,
      error: 'Invalid or missing day number'
    }, { status: 400 })
  }

  if (!dayContent || !dayContent.content) {
    return NextResponse.json({
      success: false,
      error: 'No daily content provided'
    }, { status: 400 })
  }

  const text = `üå± DAY ${dayNumber} - HEALING JOURNEY
Your personalized daily healing practice
Generated on ${new Date().toLocaleDateString()}

================================================================================

üéØ MAIN FOCUS: ${dayContent.content.mainFocus || 'Daily Healing'}

================================================================================

üåÖ GUIDED PRACTICE
================================================================================

${dayContent.content.guidedPractice || 'No guided practice available'}

================================================================================

‚ö° DAILY CHALLENGE
================================================================================

${dayContent.content.challenge || 'No daily challenge available'}

================================================================================

üìù JOURNALING PROMPT
================================================================================

${dayContent.content.journalingPrompt || 'No journaling prompt available'}

================================================================================

üåô REFLECTION
================================================================================

${dayContent.content.reflection || 'No reflection available'}

================================================================================

üå§Ô∏è WEATHER & ENVIRONMENT
================================================================================

${dayContent.content.weather || 'No weather information available'}

================================================================================

üò¥ SLEEP & WELLNESS
================================================================================

${dayContent.content.sleep || 'No sleep information available'}

================================================================================

üåø HOLISTIC HEALING BONUS
================================================================================

${dayContent.content.holistic || 'No holistic healing bonus available'}

================================================================================

End of Day ${dayNumber}
Generated by Unfuck Your Past - AI-Driven Healing Platform`

  return NextResponse.json({
    success: true,
    data: text,
    filename: `day-${dayNumber}-${userId}-${Date.now()}.txt`,
    mimeType: 'text/plain'
  })
}

async function handleDiagnosticQuestionsTXT(userId: string) {
  try {
    // Fetch all diagnostic responses with questions and AI insights
    const responses = await db
      .select({
        question: diagnosticResponses.question,
        response: diagnosticResponses.response,
        insight: diagnosticResponses.insight,
        timestamp: diagnosticResponses.createdAt
      })
      .from(diagnosticResponses)
      .where(eq(diagnosticResponses.userId, userId))
      .orderBy(diagnosticResponses.createdAt)

    if (!responses || responses.length === 0) {
      return NextResponse.json({
        success: true,
        data: 'No diagnostic responses found. Please complete the diagnostic section first.',
        filename: `diagnostic-questions-${userId}-${Date.now()}.txt`,
        mimeType: 'text/plain'
      })
    }

    let text = `üîç DIAGNOSTIC QUESTIONS & ANSWERS WITH AI INSIGHTS
Your complete diagnostic journey with personalized AI analysis
Generated on ${new Date().toLocaleDateString()}

================================================================================

üìä TOTAL RESPONSES: ${responses.length}
================================================================================

`

    responses.forEach((resp, index) => {
      const questionText = resp.question && typeof resp.question === 'object' && 'text' in resp.question ? (resp.question as { text: string }).text || `Question ${index + 1}` : `Question ${index + 1}`
      const timestamp = resp.timestamp ? new Date(resp.timestamp).toLocaleString() : 'Unknown time'
      
      text += `\n${'='.repeat(80)}\n`
      text += `QUESTION ${index + 1}: ${questionText}\n`
      text += `Timestamp: ${timestamp}\n`
      text += `${'='.repeat(80)}\n\n`
      
      text += `üìù YOUR RESPONSE:\n`
      text += `${resp.response}\n\n`
      
      text += `ü§ñ AI INSIGHT:\n`
      text += `${resp.insight || 'No AI insight available'}\n\n`
      
      text += `${'='.repeat(80)}\n\n`
    })

    text += `\n================================================================================\n`
    text += `End of Diagnostic Report\n`
    text += `Generated by Unfuck Your Past - AI-Driven Healing Platform\n`
    text += `Total Questions Answered: ${responses.length}`

    return NextResponse.json({
      success: true,
      data: text,
      filename: `diagnostic-questions-${userId}-${Date.now()}.txt`,
      mimeType: 'text/plain'
    })

  } catch (error) {
    console.error('Error generating diagnostic questions TXT:', error)
    return NextResponse.json({
      success: false,
      error: 'Failed to generate diagnostic questions report'
    }, { status: 500 })
  }
}

async function handleAllTXT(
  userId: string,
  safetyData: any,
  moods?: Array<{ rating: number; note?: string; timestamp: string }>
) {
  try {
    // Diagnostic responses
    const responses = await db
      .select({
        question: diagnosticResponses.question,
        response: diagnosticResponses.response,
        insight: diagnosticResponses.insight,
        timestamp: diagnosticResponses.createdAt
      })
      .from(diagnosticResponses)
      .where(eq(diagnosticResponses.userId, userId))
      .orderBy(diagnosticResponses.createdAt)

    // Progress
    const progressResult = await db
      .select({ day: progress.day, completedAt: progress.completedAt })
      .from(progress)
      .where(eq(progress.userId, userId))
      .orderBy(progress.day)

    // Comprehensive report if exists
    const reportResult = await db
      .select()
      .from(diagnosticSummaries)
      .where(and(
        eq(diagnosticSummaries.userId, userId),
        eq(diagnosticSummaries.type, 'comprehensive_report')
      ))
      .limit(1)

    const summary = safetyData?.diagnosticSummary?.content || 'No diagnostic summary available'
    const keyInsights = safetyData?.keyInsights || 'No key insights available'
    const comprehensive = reportResult?.[0]?.summary || 'No comprehensive report available'

    let text = `üì¶ FULL ACCOUNT EXPORT\nUser: ${userId}\nGenerated: ${new Date().toLocaleString()}\n\n`;
    text += `==============================\nDIAGNOSTIC SUMMARY\n==============================\n${summary}\n\n`;
    text += `==============================\nKEY INSIGHTS\n==============================\n${keyInsights}\n\n`;
    text += `==============================\nCOMPREHENSIVE REPORT\n==============================\n${comprehensive}\n\n`;

    text += `==============================\nQUESTIONS & ANSWERS WITH AI INSIGHTS\n==============================\n`;
    responses.forEach((resp, i) => {
      const questionText = resp.question && typeof resp.question === 'object' && 'text' in resp.question ? (resp.question as { text: string }).text || `Question ${i + 1}` : `Question ${i + 1}`
      const timestamp = resp.timestamp ? new Date(resp.timestamp).toLocaleString() : 'Unknown time'
      text += `\nQ${i + 1}: ${questionText}\nTime: ${timestamp}\n`;
      text += `Answer:\n${resp.response}\n`;
      text += `AI Insight:\n${resp.insight || 'No AI insight'}\n`;
      text += `------------------------------\n`;
    })

    text += `\n==============================\n30-DAY PROGRAM PROGRESS\n==============================\n`;
    text += `Completed Days: ${progressResult.length}/30\n`;
    progressResult.forEach((p) => {
      text += `Day ${p.day} - completed at ${p.completedAt ? new Date(p.completedAt).toLocaleString() : 'unknown'}\n`;
    })

    if (Array.isArray(moods) && moods.length > 0) {
      text += `\n==============================\nMOOD ENTRIES\n==============================\n`;
      moods.forEach((m, idx) => {
        text += `#${idx + 1} Rating: ${m.rating}/10  Time: ${new Date(m.timestamp).toLocaleString()}\n`;
        if (m.note) text += `Note: ${m.note}\n`;
      })
    }

    text += `\n==============================\nEND OF EXPORT\nGenerated by Unfuck My Past\n`;

    return NextResponse.json({
      success: true,
      data: text,
      filename: `all-data-${userId}-${Date.now()}.txt`,
      mimeType: 'text/plain'
    })
  } catch (error) {
    console.error('Error generating full export:', error)
    return NextResponse.json({ success: false, error: 'Failed to generate full export' }, { status: 500 })
  }
}

export async function GET() {
  try {
    const { userId } = await auth()
    
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user data
    const userResult = await db.select().from(users).where(eq(users.id, userId)).limit(1)
    if (!userResult || userResult.length === 0) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    const user = userResult[0]
    const safetyData = typeof user.safety === 'string' ? JSON.parse(user.safety) : user.safety

    // Get diagnostic responses
    const answersResult = await db.select({
      question: diagnosticResponses.question,
      content: diagnosticResponses.response,
      summary: diagnosticResponses.insight,
      createdAt: diagnosticResponses.createdAt
    })
    .from(diagnosticResponses)
    .where(eq(diagnosticResponses.userId, userId))
    .orderBy(diagnosticResponses.createdAt)

    // Get program progress
    const progressResult = await db.select({
      day: progress.day,
      completedAt: progress.completedAt
    })
    .from(progress)
    .where(eq(progress.userId, userId))
    .orderBy(progress.day)

    // Get purchases
    const purchasesResult = await db.select({
      product: purchases.product,
      createdAt: purchases.createdAt,
      active: purchases.active
    })
    .from(purchases)
    .where(eq(purchases.userId, userId))
    .orderBy(purchases.createdAt)

    // Format data for export
    const exportData = {
      user: {
        id: userId,
        preferences: {
          tone: user.tone || 'gentle',
          voice: user.voice || 'friend',
          rawness: user.rawness || 'moderate',
          depth: user.depth || 'moderate',
          learning: user.learning || 'text',
          engagement: user.engagement || 'passive'
        }
      },
      diagnostic: {
        responses: answersResult.map(answer => ({
          question: answer.question,
          response: answer.content || '',
          insight: answer.summary || '',
          timestamp: answer.createdAt?.toISOString() || ''
        })),
        summary: safetyData.diagnosticSummary?.content || 'No diagnostic summary available'
      },
      program: {
        progress: {
          completed: progressResult.length,
          total: 30,
          percentage: Math.round((progressResult.length / 30) * 100),
          currentDay: progressResult.length > 0 ? Math.max(...progressResult.map(p => p.day)) + 1 : 1,
          streak: calculateStreak(progressResult.map(p => p.day))
        },
        completedDays: progressResult.map(p => ({
          day: p.day,
          title: `Day ${p.day}`,
          completedAt: p.completedAt?.toISOString() || ''
        }))
      },
      purchases: purchasesResult.map(p => ({
        product: p.product,
        purchasedAt: p.createdAt?.toISOString() || '',
        active: p.active ?? false
      }))
    }

    return NextResponse.json(exportData)

  } catch (error) {
    console.error('Error exporting data:', error)
    return NextResponse.json(
      { error: 'Failed to export data' },
      { status: 500 }
    )
  }
}

function calculateStreak(completedDays: number[]): number {
  if (completedDays.length === 0) return 0
  
  let streak = 0
  const sortedDays = completedDays.sort((a, b) => a - b)
  
  for (let i = 1; i <= Math.max(...sortedDays); i++) {
    if (sortedDays.includes(i)) {
      streak++
    } else {
      break
    }
  }
  
  return streak
}
